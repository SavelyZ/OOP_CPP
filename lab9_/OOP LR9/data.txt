Лабораторная работа № 2

Ассоциативные контейнеры библиотеки STL

Цель работы: Освоить технологию обобщенного программирования с использо-ванием библиотеки стандартных шаблонов (STL) языка C++.

Практическое задание

Написать программу формирования частотного словаря (с использованием контей-нерного класса map библиотеки STL) появления отдельных слов в некотором тексте. Ис-ходный текст читается из файла . txt, результат - частотный словарь. Предусмотреть воз-можность работы со словарем: поиска заданного слова в словаре, сортировки по разным полям, просмотра словаря, вывода наиболее часто встречающегося слова, слова, встреча-ющегося реже всего, вывод слов с частотами на заданную букву. Работу со словарем ор-ганизовать с использованием алгоритмов библиотеки STL. По окончании работы со сло-варем предусмотреть запись словаря в файл .txt.

Краткие теоретические сведения.

Основные концепции STL

Стандартная библиотека шаблонов STL состоит из двух основных частей: набора контейнерных классов и набора обобщенных алгоритмов.

Контейнеры — это объекты, содержащие другие однотипные объекты. Контейнер-ные классы являются шаблонными, поэтому хранимые в них объекты могут быть как встроенных, так и пользовательских типов. Эти объекты должны допускать копирование и присваивание. Встроенные типы этим требованиям удовлетворяют; то же самое относится к классам, если конструктор копирования или операция присваивания не объявлены в них закрытыми или защищенными. В контейнерных классах реализованы такие типовые структуры данных, как стек, список, очередь и т. д.

Обобщенные алгоритмы реализуют большое количество процедур, применимых к контейнерам - например, поиск, сортировку, слияние и т. п. Однако они не являются ме-тодами контейнерных классов. Алгоритмы представлены в STL в форме глобальных шаб-лонных функций. Благодаря этому достигается их универсальность: эти функции можно применять не только к объектам различных контейнерных классов, но также и к массивам. Независимость от типов контейнеров достигается за счет косвенной связи функции с кон-тейнером: в функцию передается не сам контейнер, а пара адресов first, last, задающая диапазон обрабатываемых элементов.

Реализация указанного механизма взаимодействия базируется на использовании так называемых итераторов. Итераторы - это обобщение концепции указателей, это более абстрактная сущность, чем указатель, но обладающая похожим поведением. Для всех кон-тейнерных классов STL определен тип Iterator, однако реализация его в разных классах разная. Например, в классе vect, где объекты размещаются один за другим, как в массиве, тип итератора определяется посредством typedef Т* iterator. А в классе list тип итератора реализован как встроенный класс iterator, поддерживающий основные операции с итера-торами.

К основным операциям, выполняемым с любыми итераторами, относятся:

- Разыменование итератора: если р — итератор, то *р — значение объекта, на ко-торый он ссылается.

- Присваивание одного итератора другому.

- Сравнение итераторов на равенство и неравенство (== и !=).

- Перемещение его по всем элементам контейнера с помощью префиксного (++р) или постфиксного (р++) инкремента.

Так как реализация итератора специфична для каждого класса, то при объявлении объектов типа итератор всегда указывается область видимости в форме имя_шаблона::, например:

vector<int>::iterator iter1;

1ist<Man>::iterator iter2:

Организация циклов просмотра элементов контейнеров тоже имеет специфику. Ес-ли i — некоторый итератор, то вместо привычной формы

for (i =0: i < n; ++i)

используется следующая:

for (i = first; i!= last; ++i)

где first — значение итератора, указывающее на первый элемент в контейнере,

last — значение итератора, указывающее на воображаемый элемент, который сле-дует за последним элементом контейнера. Операция сравнения < здесь заменена на опера-цию !=, поскольку операции < и > для итераторов в общем случае не поддерживаются.

Для всех контейнерных классов определены унифицированные методы begin() и end(), возвращающие адреса first и last соответственно.

Контейнеры

Контейнеры STL молено разделить на два типа: последовательные и ассоциатив-ные.

Последовательные контейнеры обеспечивают хранение конечного количества од-нотипных объектов в виде непрерывной последовательности. К базовым последователь-ным контейнерам относятся векторы (vector), списки (list) и двунаправленные очереди (deque). Есть еще специализированные контейнеры (или адаптеры контейнеров), реализо-ванные на основе базовых - стеки (stack), очереди (queue) и очереди с приоритетами (priority_queue).

Для использования контейнера в программе необходимо включить в нее соответ-ствующий заголовочный файл.

Использование ассоциативных контейнеров

В ассоциативных контейнерах элементы не выстроены в линейную последователь-ность. Они организованы в более сложные структуры, что дает большой выигрыш в ско-рости поиска. Поиск производится с помощью ключей, обычно представляющих собой одно числовое или строковое значение. Рассмотрим две основные категории ассоциатив-ных контейнеров в STL: множества и словари.

В множестве (set) хранятся объекты, упорядоченные по некоторому ключу, явля-ющемуся атрибутом самого объекта. Например, множество может хранить объекты класса Man, упорядоченные в алфавитном порядке по значению ключевого поля name. Если в множестве хранятся значения одного из встроенных типов, например int, то ключом явля-ется сам элемент.

Словарь (mар) можно представить как таблицу из двух столбцов, в первом из кото-рых хранятся объекты, содержащие ключи, а во втором — объекты, содержащие значения. И в множествах, и в словарях все ключи являются уникальными (только одно значение соответствует ключу). Мультимножества (multiset) и мультисловари (multlmap) аналогич-ны своим родственным контейнерам, но в них одному ключу может соответствовать не-сколько значений.

Ассоциативные контейнеры имеют много общих методов с последовательными контейнерами. Тем не менее, некоторые методы, а также алгоритмы характерны только для них.

Словари

В определении класса mар используется тип pair, который описан в заголовочном файле <utility> следующим образом:

template <class Tl, class Т2> struct pair{

Tl first;

T2 second;

pair(const T1& X. const T2& y);

}

Шаблон pair имеет два параметра, представляющих собой типы элементов пары. Первый элемент пары имеет имя first, второй — second. В этом же файле определены шаблонные операции ==, !=, <, >, <=, >= для двух объектов типа pair.

Шаблон словаря имеет три параметра: тип ключа, тип элемента и тип функцио-нального объекта, определяющего отношение «меньше»:

template <class Key, class Т, class Compare = less<Key> >

class map {

public:

typedef pair <const Key, T> value_type;

explicit map(const Compare& comp = Compare());

map(const value_type* first , const value_type* last,

const Compare& comp = Compare());

map(const map <Key, T, Compare>& x);

}

Обратите внимание на то, что тип элементов словаря value_type определяется как пара элементов типа Key и Т.

Первый конструктор класса mар создает пустой словарь. Второй - создает словарь и записывает в него элементы, определяемые диапазоном [first, 1ast). Третий конструктор является конструктором копирования.

Для доступа к элементам по ключу определена операция []:

Т& operator[](const Key & х):

С помощью нее можно не только получать значения элементов, но и добавлять в словарь новые.

Для использования контейнеров типа map необходимо подключить заголовочный файл <map>.